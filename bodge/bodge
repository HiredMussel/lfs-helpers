#!/bin/sh

# Declare global program variables
BODGE_CFLAGS=
BODGE_CXXFLAGS=

BODGE_DEFAULT_PACKAGE_PATH=/home/buildbox/Development/lfs-helpers/bodge
BODGE_DEFAULT_ROOT=/home/buildbox/Development/lfs-helpers/fakeroot

# Put the global program variables into the expected formats
[ ! -z "$BODGE_PACKAGE_PATH" ] \
    && BODGE_PACKAGE_PATH=$BODGE_PACKAGE_PATH \
    || BODGE_PACKAGE_PATH=$BODGE_DEFAULT_PACKAGE_PATH

[ ! -z "$BODGE_ROOT" ] \
    && BODGE_ROOT=$BODGE_ROOT \
    || BODGE_ROOT=$BODGE_DEFAULT_ROOT

BODGE_PACKAGE_PATH=$(echo $BODGE_PACKAGE_PATH | sed 's@/*$@@')
BODGE_ROOT=$(echo $BODGE_ROOT | sed 's@/*$@/@')

# Helper functions for creating and editing the package config

# Create the package - a package is a shell script containing instructions on
# how the package is to be installed with the configuration options set by 
# specific comments within the file.
create_pkg() {
    [ $# -eq 0 ] \
        && echo "All packages created successfully" \
        && return 1

    [ ! -d $BODGE_PACKAGE_PATH ] \
        && echo "Please create $BODGE_PACKAGE_PATH to proceed" \
        && return 2

    echo "Creating package $1 in $BODGE_PACKAGE_PATH/$1"

    [ ! -d $BODGE_PACKAGE_PATH/$1 ] \
        && mkdir $BODGE_PACKAGE_PATH/$1

    [ -e $BODGE_PACKAGE_PATH/$1/PKGBUILD ] \
        && echo "Package $1 already exists" \
        && return 3

    touch $BODGE_PACKAGE_PATH/$1/PKGBUILD
    cat << EOF > $BODGE_PACKAGE_PATH/$1/PKGBUILD
#!/bin/sh

# [General]
#
# [Version]
# stable_version=
# version_listing=
# version_scheme=
# latest_version=
# current_version=
# installed_version=
#
# [Build]
# distfiles=
#
# [Dependencies]
# depends_on=
# depended_on_by=
# lock=

EOF
    echo "Created package $1 successfully"
}

# Retrieve a key from a package
get_pkg_data() {
    [ $# -eq 0 ] \
        && echo "No configuration option selected" \
        && return 1

    config_option=$1
    shift

    [ $# -eq 0 ] \
        && return

    [ ! -e $BODGE_PACKAGE_PATH/$1/PKGBUILD ] \
        && echo "Could not find configuration for package $1" \
        && return 3

    sed -n "s@#\ *$config_option=\ *\(.*\)\($\)@\1@p" $BODGE_PACKAGE_PATH/$1/PKGBUILD

    shift
    get_pkg_data $config_option $@
}

# Change a key in a package
change_pkg_data() {
    [ $# -eq 0 ] \
        && echo "No configuration option selected" \
        && return 1

    [ $# -eq 1 ] \
        && echo "No new value for option $1 provided" \
        && return 2

    config_option=$1
    config_value=$2
    shift 2

    [ $# -eq 0 ] \
        && return

    [ ! -e $BODGE_PACKAGE_PATH/$1/PKGBUILD ] \
        && echo "Could not find package configuration" \
        && return 3

    sed -i "s@\(#\ *$config_option=\).*@\1$config_value@" $BODGE_PACKAGE_PATH/$1/PKGBUILD

    echo "Succesfully set $config_option to $config_value for package $1"
}

# Add a key to a package
add_pkg_data() {
    [ $# -eq 0 ] \
        && echo "No package name provided" \
        && return 1

    [ $# -eq 1 ] \
        && echo "No configuration option selected" \
        && return 2

    config_option=$1
    config_value=$2
    shift 2

    [ $# -eq 0 ] \
        && return

    [ ! -e $BODGE_PACKAGE_PATH/$1/PKGBUILD ] \
        && echo "Could not find package configuration" \
        && return 3

    sed -i "s@#\ *\[General\]@\0\n#\ $config_option=$config_value@" $BODGE_PACKAGE_PATH/$1/PKGBUILD

    echo "Successfully set key $config_option to value $config_value for package $1"
}

# Set a key in a package
modify_pkg_data() {
    [ $# -eq 0 ] \
        && echo "No configuration option selected" \
        && return 1

    [ $# -eq 1 ] \
        && echo "No new value for option $1 provided" \
        && return 2

    config_option=$1
    config_value=$2
    shift 2

    [ $# -eq 0 ] \
        && return

    [ ! -e $BODGE_PACKAGE_PATH/$1/PKGBUILD ] \
        && echo "Could not find configuration for package $1" \
        && return 3

    change_pkg_data $config_option $config_value $1

    package_exists=$(get_pkg_data $config_option $1)

    [ -z "$package_exists" ] \
        && add_pkg_data $config_option $config_value $1

    shift
    modify_pkg_data $config_option $config_value $@
}

# Delete a key in a package
delete_pkg_data() {
    [ $# -eq 0 ] \
        && echo "No key to delete selected" \
        && return 1

    config_option=$1
    shift

    [ $# -eq 0 ] \
        && return

    sed -i "s@\(#\ *$config_option=\).*@\1@" $BODGE_PACKAGE_PATH/$1/PKGBUILD

    echo "Successfully cleared value of $config_option for package $1"

    shift
    delete_pkg_data $config_option $@
}

# Generalised installation script - works by linking all files to the install location

install_package_files() {
    [ ! -d $2 ] \
        && echo "Installation folder does not exist!" \
        && return 1

    for folder in $(cd $2 && find -type d)
    do
        mkdir -p $1$folder
    done

    for file in $(cd $2 && find \! -type d,l)
    do
        truncated_file=$(echo $file | awk '{print substr($1,2)}')
        [ ! -f $1$truncated_file ] \
            && ln -sf $2$truncated_file $1$truncated_file
    done

    for link in $(cd $2 && find -type l)
    do
        truncated_link=$(echo $link | awk '{print substr($1,2)}')
        [ ! -f $1$truncated_link ] \
            && [ ! -z $(readlink -f $2$truncated_link | grep $2) ] \
            && ln -sf $2$truncated_link $1$truncated_link
    done
}

# Helper functions for managing the program flow

# Prompt the user for input
check_proceed() {
    read -p "Proceed? ([Y]es or [N]o)" proceed

    proceed=$(echo $proceed | awk '{print substr($1,1,1)}')

    case $proceed in
        Y|y) echo "" && run_operation $@
        ;;
        N|n) echo "" && exit 
        ;;
        *) echo "" && check_proceed $@ 
        ;;
    esac
}

# Work out the functions to run
parse_arguments() {
    [ ! -z "$(echo $1 | grep -- "^\ *C.*")" ] \
        && echo " * Create the packages"

    [ ! -z "$(echo $1 | grep -- "^\ *M.*")" ] \
        && echo " * Set $2 to $3 for each package"

    [ ! -z "$(echo $1 | grep -- "^\ *D.*")" ] \
        && echo " * Clear the value of $2 for each package"

    [ ! -z "$(echo $1 | grep -- "^\ *G.*")" ] \
        && echo " * Return the value of $2 for each package"

    [ ! -z "$(echo $1 | grep -- "^\ *I.*")" ] \
        && echo " * Install each package to $BODGE_ROOT"

    newarg=$(echo $1 | sed 's@[\ \-]*.@@')
    shift

    [ -z $newarg ] \
        && return

    parse_arguments $newarg $@
}

# actually run each of the operations in order
run_operation() {
    operations_to_run=$1
    shift

    config_option=$1
    config_value=$2
    shift 2

    [ ! -z "$(echo $operations_to_run | grep -- "\-C.*")" ] \
        && for package in $@
        do
            create_pkg $package
        done

    [ ! -z "$(echo $operations_to_run | grep -- "\-M.*")" ] \
        && modify_pkg_data $config_option $config_value $@

    [ ! -z "$(echo $operations_to_run | grep -- "\-D.*")" ] \
        && delete_pkg_data $config_option $@

    [ ! -z "$(echo $operations_to_run | grep -- "\-G.*")" ] \
        && get_pkg_data $config_option $@

    [ ! -z "$(echo $operations_to_run | grep -- "\-I.*")" ] \
        && for package in $@
        do
            install_package_files $BODGE_ROOT $BODGE_PACKAGE_PATH/$package/$(get_pkg_data current_version $package)/dist/
            [ $? -eq 0 ] && modify_pkg_data installed_version $(get_pkg_data current_version $package) $package
        done

    newarg=$(echo $operations_to_run | sed 's@[\ \-]*.@@')

    [ -z "$(echo $newarg | awk '{print substr($1,1,1)}')" ] \
        && exit

    run_operation -$newarg $config_option $config_value $@
}

# Main program flow

# Pop the first argument off the stack
operations_to_run=$(echo $1 | sed 's@[\ \-]*@@')
shift

# Handle the cases where we take in a configuration option
config_option="config_option"

[ ! -z "$(echo $operations_to_run | grep -- ".*[MDG].*")" ] \
    && config_option=$1 \
    && shift

# Handle the cases where we take in a value for the configuration option
config_value="config_value"

[ ! -z "$(echo $operations_to_run | grep -- ".*[M].*")" ] \
    && config_value=$1 \
    && shift

packages=$(echo $@ | tr " " "\n" | sort -u | tr "\n" " ")

echo "This command will affect the following packages:"
echo ""
echo $packages

echo ""
echo "The following operations will be attempted in order:"

parse_arguments $operations_to_run $config_option $config_value

echo ""

check_proceed -$operations_to_run $config_option $config_value $packages
